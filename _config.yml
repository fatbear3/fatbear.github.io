# Site settings
title: 北极熊说地理
SEOTitle: 北极熊说地理 

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>北极熊说地理</title>
    <style>
        body {
            font-family: 'Comic Sans MS', 'Marker Felt', '微软雅黑', sans-serif;
            background-color: #e0f7fa;
            margin: 0;
            padding: 20px;
            background-image: linear-gradient(to bottom, #e0f7fa, #b3e5fc);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 0 30px rgba(0, 150, 200, 0.4);
            border: 5px solid #b3e5fc;
            position: relative;
            overflow: hidden;
        }
        
        .container::before {
            content: "";
            position: absolute;
            top: -50px;
            right: -50px;
            width: 200px;
            height: 200px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            z-index: 0;
        }
        
        header {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
            z-index: 1;
        }
        
        h1 {
            color: #0077b6;
            font-size: 3em;
            margin: 0;
            text-shadow: 3px 3px 0 #b3e5fc, 5px 5px 0 rgba(0, 150, 200, 0.2);
            letter-spacing: 2px;
            position: relative;
            display: inline-block;
        }
        
        h1::after {
            content: "❄";
            position: absolute;
            right: -30px;
            top: -10px;
            font-size: 1.5em;
            color: white;
            text-shadow: 1px 1px 2px #0077b6;
        }
        
        h2 {
            color: #00b4d8;
            font-size: 2em;
            margin: 5px 0 15px;
            text-shadow: 2px 2px 0 rgba(179, 229, 252, 0.5);
        }
        
        .lesson-selector {
            background-color: rgba(179, 229, 252, 0.8);
            padding: 15px;
            border-radius: 15px;
            margin-bottom: 20px;
            text-align: center;
            backdrop-filter: blur(5px);
            border: 2px solid white;
        }
        
        .lesson-selector.hidden {
            display: none;
        }
        
        .lesson-selector label {
            font-size: 1.2em;
            color: #0077b6;
            margin-right: 10px;
            font-weight: bold;
        }
        
        .lesson-selector input, .lesson-selector button {
            padding: 8px 15px;
            border-radius: 10px;
            border: 2px solid #0077b6;
            background-color: white;
            font-size: 1em;
            transition: all 0.3s;
        }
        
        .lesson-selector button {
            background-color: #0077b6;
            color: white;
            cursor: pointer;
        }
        
        .lesson-selector button:hover {
            background-color: #00b4d8;
            transform: scale(1.05);
        }
        
        .toolbar {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            flex-wrap: wrap;
            background-color: rgba(179, 229, 252, 0.8);
            padding: 10px;
            border-radius: 15px;
            backdrop-filter: blur(5px);
            border: 2px solid white;
        }
        
        .color-options, .tool-options, .page-options {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .color-btn, .tool-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 3px solid white;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .color-btn:hover, .tool-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .black { background-color: black; }
        .blue { background-color: #0077b6; }
        .red { background-color: #e63946; }
        .green { background-color: #2a9d8f; }
        .eraser { background-color: white; border: 3px dashed #0077b6; }
        .stroke-eraser { background-color: #f8f9fa; border: 3px dotted #0077b6; }
        .clear { background-color: #ffd166; display: flex; justify-content: center; align-items: center; }
        .text-tool { background-color: #a7c4bc; display: flex; justify-content: center; align-items: center; }
        .shape-tool { background-color: #b8b8ff; display: flex; justify-content: center; align-items: center; }
        
        .page-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .page-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: #0077b6;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .page-btn:hover {
            background-color: #00b4d8;
            transform: scale(1.1);
        }
        
        .page-indicator {
            font-weight: bold;
            color: #0077b6;
        }
        
        .drawing-board {
            width: 100%;
            height: 700px;
            background-color: white;
            border: 10px solid #b3e5fc;
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
            touch-action: none;
            background-image: radial-gradient(circle at 10px 10px, #e0f7fa 1px, transparent 1px);
            background-size: 20px 20px;
        }
        
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            touch-action: none;
        }
        
        .iceberg {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 50px;
            background-color: #e0f7fa;
            clip-path: polygon(0% 100%, 5% 70%, 10% 90%, 15% 60%, 20% 80%, 25% 50%, 30% 70%, 35% 40%, 40% 60%, 45% 30%, 50% 50%, 55% 20%, 60% 40%, 65% 10%, 70% 30%, 75% 0%, 80% 20%, 85% 0%, 90% 10%, 95% 0%, 100% 100%);
        }
        
        footer {
            text-align: center;
            margin-top: 20px;
            color: #0077b6;
            font-size: 0.9em;
            padding: 10px;
            border-top: 2px dashed #b3e5fc;
        }
        
        .clear-icon {
            font-size: 1.2em;
            color: #0077b6;
        }
        
        .stroke-eraser-icon {
            font-size: 1em;
            color: #0077b6;
        }
        
        .text-icon {
            font-size: 1.2em;
            color: #0077b6;
        }
        
        .shape-icon {
            font-size: 1.2em;
            color: #0077b6;
        }
        
        .text-editor {
            position: absolute;
            background: white;
            border: 2px solid #0077b6;
            border-radius: 10px;
            padding: 15px;
            z-index: 100;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            width: 250px;
        }
        
        .text-editor-header {
            font-size: 1.1em;
            color: #0077b6;
            margin-bottom: 10px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .text-editor-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 10px;
        }
        
        .text-editor select, .text-editor input {
            padding: 6px;
            border: 1px solid #b3e5fc;
            border-radius: 6px;
            background-color: white;
        }
        
        .text-input {
            width: 100%;
            height: 80px;
            margin: 10px 0;
            padding: 8px;
            border: 1px solid #b3e5fc;
            border-radius: 6px;
            resize: none;
            font-family: inherit;
        }
        
        .text-editor-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }
        
        .text-editor button {
            padding: 6px 12px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        #confirm-text {
            background-color: #0077b6;
            color: white;
        }
        
        #confirm-text:hover {
            background-color: #00b4d8;
        }
        
        #cancel-text {
            background-color: #e63946;
            color: white;
        }
        
        #cancel-text:hover {
            background-color: #ff6b6b;
        }
        
        .shape-selector {
            position: absolute;
            background: white;
            border: 2px solid #0077b6;
            border-radius: 10px;
            padding: 10px;
            z-index: 100;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            width: 180px;
        }
        
        .shape-selector-header {
            font-size: 1.1em;
            color: #0077b6;
            margin-bottom: 10px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .shape-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }
        
        .shape-option {
            padding: 8px;
            cursor: pointer;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #b3e5fc;
            transition: all 0.2s;
        }
        
        .shape-option:hover {
            background-color: #e0f7fa;
            transform: scale(1.05);
        }
        
        .shape-icon-large {
            font-size: 1.5em;
            display: block;
            margin-bottom: 4px;
        }
        
        .drawing-cursor {
            cursor: crosshair;
        }
        
        /* 北极熊元素装饰 */
        .polar-bear-decoration {
            position: absolute;
            z-index: 0;
            opacity: 0.1;
            pointer-events: none;
        }
        
        .bear-paw {
            position: absolute;
            width: 60px;
            height: 60px;
            background-color: white;
            border-radius: 50%;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.1));
        }
        
        .bear-paw::before, .bear-paw::after {
            content: "";
            position: absolute;
            background-color: white;
            border-radius: 50%;
        }
        
        .bear-paw-1 {
            top: 50px;
            left: 30px;
            transform: rotate(30deg);
        }
        
        .bear-paw-1::before {
            width: 20px;
            height: 30px;
            top: -15px;
            left: 10px;
        }
        
        .bear-paw-1::after {
            width: 20px;
            height: 30px;
            top: -15px;
            right: 10px;
        }
        
        .bear-paw-2 {
            bottom: 70px;
            right: 40px;
            transform: rotate(-20deg);
        }
        
        .bear-paw-2::before {
            width: 20px;
            height: 30px;
            top: -15px;
            left: 10px;
        }
        
        .bear-paw-2::after {
            width: 20px;
            height: 30px;
            top: -15px;
            right: 10px;
        }
        
        .snowflake {
            position: absolute;
            color: white;
            font-size: 1.2em;
            animation: falling linear infinite;
        }
        
        @keyframes falling {
            0% {
                transform: translateY(-10px) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- 北极熊装饰元素 -->
        <div class="polar-bear-decoration bear-paw bear-paw-1"></div>
        <div class="polar-bear-decoration bear-paw bear-paw-2"></div>
        
        <header>
            <h1>北极熊说地理</h1>
            <h2 id="lesson-title">第1课</h2>
        </header>
        
        <div class="lesson-selector" id="lesson-selector">
            <label for="lesson-input">输入课程编号：</label>
            <input type="number" id="lesson-input" min="1" value="1">
            <button id="change-lesson">开始课程</button>
        </div>
        
        <div class="toolbar">
            <div class="color-options">
                <div class="color-btn black selected" data-color="black"></div>
                <div class="color-btn blue" data-color="#0077b6"></div>
                <div class="color-btn red" data-color="#e63946"></div>
                <div class="color-btn green" data-color="#2a9d8f"></div>
            </div>
            
            <div class="tool-options">
                <div class="tool-btn eraser" title="区域橡皮擦"></div>
                <div class="tool-btn stroke-eraser" title="笔画橡皮擦"><span class="stroke-eraser-icon">S</span></div>
                <div class="tool-btn text-tool" title="添加文字"><span class="text-icon">T</span></div>
                <div class="tool-btn shape-tool" title="绘制形状"><span class="shape-icon">△</span></div>
                <div class="tool-btn clear" title="清屏"><span class="clear-icon">×</span></div>
            </div>
            
            <div class="page-options">
                <div class="page-controls">
                    <div class="page-btn" id="prev-page">←</div>
                    <span class="page-indicator">第 <span id="current-page">1</span> 页</span>
                    <div class="page-btn" id="next-page">→</div>
                </div>
                <button id="add-page">+ 添加页</button>
            </div>
        </div>
        
        <div class="drawing-board">
            <canvas id="drawing-canvas"></canvas>
            <div class="iceberg"></div>
        </div>
        
        <div class="text-editor" id="text-editor">
            <div class="text-editor-header">
                <span>添加文字</span>
                <span id="close-text-editor" style="cursor:pointer;">×</span>
            </div>
            <div class="text-editor-controls">
                <select id="font-family">
                    <option value="SimSun,宋体">宋体</option>
                    <option value="SimHei,黑体">黑体</option>
                </select>
                <select id="font-size">
                    <option value="100px">一号</option>
                    <option value="90px">二号</option>
                    <option value="80px" selected>三号</option>
                    <option value="70px">四号</option>
                    <option value="60px">五号</option>
                </select>
                <select id="text-color">
                    <option value="black">黑色</option>
                    <option value="#0077b6">蓝色</option>
                    <option value="#e63946">红色</option>
                    <option value="#2a9d8f">绿色</option>
                </select>
            </div>
            <textarea class="text-input" id="text-input" placeholder="输入文字内容"></textarea>
            <div class="text-editor-buttons">
                <button id="cancel-text">取消</button>
                <button id="confirm-text">确定</button>
            </div>
        </div>
        
        <div class="shape-selector" id="shape-selector">
            <div class="shape-selector-header">
                <span>选择形状</span>
                <span id="close-shape-selector" style="cursor:pointer;">×</span>
            </div>
            <div class="shape-grid">
                <div class="shape-option" data-shape="line">
                    <span class="shape-icon-large">—</span>
                    <span>直线</span>
                </div>
                <div class="shape-option" data-shape="rectangle">
                    <span class="shape-icon-large">▭</span>
                    <span>长方形</span>
                </div>
                <div class="shape-option" data-shape="square">
                    <span class="shape-icon-large">□</span>
                    <span>正方形</span>
                </div>
                <div class="shape-option" data-shape="circle">
                    <span class="shape-icon-large">○</span>
                    <span>圆形</span>
                </div>
                <div class="shape-option" data-shape="parallelogram">
                    <span class="shape-icon-large">▱</span>
                    <span>平行四边形</span>
                </div>
                <div class="shape-option" data-shape="trapezoid">
                    <span class="shape-icon-large">⏢</span>
                    <span>梯形</span>
                </div>
            </div>
        </div>
        
        <footer>
            © 2025 北极熊说地理 - 和可爱的北极熊一起学习地理知识吧！
        </footer>
    </div>

    <script>
        // 创建雪花效果
        function createSnowflakes() {
            const container = document.querySelector('.container');
            const snowflakeCount = 15;
            
            for (let i = 0; i < snowflakeCount; i++) {
                const snowflake = document.createElement('div');
                snowflake.className = 'snowflake';
                snowflake.innerHTML = '❄';
                snowflake.style.left = Math.random() * 100 + '%';
                snowflake.style.animationDuration = (Math.random() * 5 + 5) + 's';
                snowflake.style.animationDelay = Math.random() * 5 + 's';
                container.appendChild(snowflake);
            }
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            createSnowflakes();
            
            const canvas = document.getElementById('drawing-canvas');
            const ctx = canvas.getContext('2d');
            const colorButtons = document.querySelectorAll('.color-btn');
            const eraserBtn = document.querySelector('.eraser');
            const strokeEraserBtn = document.querySelector('.stroke-eraser');
            const textToolBtn = document.querySelector('.text-tool');
            const shapeToolBtn = document.querySelector('.shape-tool');
            const clearBtn = document.querySelector('.clear');
            const prevPageBtn = document.getElementById('prev-page');
            const nextPageBtn = document.getElementById('next-page');
            const addPageBtn = document.getElementById('add-page');
            const currentPageSpan = document.getElementById('current-page');
            const lessonInput = document.getElementById('lesson-input');
            const changeLessonBtn = document.getElementById('change-lesson');
            const lessonTitle = document.getElementById('lesson-title');
            const lessonSelector = document.getElementById('lesson-selector');
            
            const textEditor = document.getElementById('text-editor');
            const textInput = document.getElementById('text-input');
            const fontFamilySelect = document.getElementById('font-family');
            const fontSizeSelect = document.getElementById('font-size');
            const textColorSelect = document.getElementById('text-color');
            const confirmTextBtn = document.getElementById('confirm-text');
            const cancelTextBtn = document.getElementById('cancel-text');
            const closeTextEditor = document.getElementById('close-text-editor');
            
            const shapeSelector = document.getElementById('shape-selector');
            const shapeOptions = document.querySelectorAll('.shape-option');
            const closeShapeSelector = document.getElementById('close-shape-selector');
            
            function resizeCanvas() {
                const board = document.querySelector('.drawing-board');
                canvas.width = board.offsetWidth;
                canvas.height = board.offsetHeight;
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            let isDrawing = false;
            let currentColor = 'black';
            let currentTool = 'pen';
            let penWidth = 3;
            let eraserWidth = 15;
            let strokeEraserWidth = 25;
            
            let strokes = [];
            let currentStroke = null;
            
            let textPosition = { x: 0, y: 0 };
            
            let currentShape = null;
            let isDrawingShape = false;
            let shapeStartX = 0;
            let shapeStartY = 0;
            let tempCanvas = document.createElement('canvas');
            let tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            
            let pages = [];
            let currentPageIndex = 0;
            
            function initPage() {
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                pages[currentPageIndex] = canvas.toDataURL();
                strokes = [];
            }
            
            initPage();
            
            function startDrawing(e) {
                if (currentTool === 'text' || currentTool === 'shape') return;
                
                isDrawing = true;
                
                const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                
                const rect = canvas.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                
                currentStroke = {
                    tool: currentTool,
                    color: currentColor,
                    width: currentTool === 'eraser' ? eraserWidth : penWidth,
                    points: [{x, y}]
                };
                
                ctx.beginPath();
                ctx.moveTo(x, y);
                
                e.preventDefault();
            }
            
            function draw(e) {
                if (!isDrawing || currentTool === 'text' || currentTool === 'shape') return;
                
                const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                
                const rect = canvas.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                
                if (currentStroke) {
                    currentStroke.points.push({x, y});
                }
                
                const currentWidth = currentTool === 'eraser' ? eraserWidth : penWidth;
                ctx.lineWidth = currentWidth;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                if (currentTool === 'eraser') {
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.strokeStyle = 'rgba(0, 0, 0, 1)';
                } else {
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.strokeStyle = currentColor;
                }
                
                ctx.lineTo(x, y);
                ctx.stroke();
                
                e.preventDefault();
            }
            
            function stopDrawing() {
                if (!isDrawing) return;
                isDrawing = false;
                
                if (currentStroke && currentStroke.points.length > 1) {
                    strokes.push(currentStroke);
                }
                currentStroke = null;
                
                pages[currentPageIndex] = canvas.toDataURL();
            }
            
            function eraseStrokeAtPoint(x, y) {
                const eraseRadius = strokeEraserWidth / 2;
                const erasedStrokeIndices = [];
                
                strokes.forEach((stroke, index) => {
                    for (let i = 0; i < stroke.points.length; i++) {
                        const point = stroke.points[i];
                        const distance = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));
                        
                        if (distance <= eraseRadius) {
                            erasedStrokeIndices.push(index);
                            break;
                        }
                    }
                });
                
                if (erasedStrokeIndices.length > 0) {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    strokes.forEach((stroke, index) => {
                        if (!erasedStrokeIndices.includes(index)) {
                            drawStroke(stroke);
                        }
                    });
                    
                    strokes = strokes.filter((_, index) => !erasedStrokeIndices.includes(index));
                    
                    pages[currentPageIndex] = canvas.toDataURL();
                }
            }
            
            function drawStroke(stroke) {
                ctx.beginPath();
                ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                
                ctx.lineWidth = stroke.width;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                if (stroke.tool === 'eraser') {
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.strokeStyle = 'rgba(0, 0, 0, 1)';
                } else {
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.strokeStyle = stroke.color;
                }
                
                for (let i = 1; i < stroke.points.length; i++) {
                    ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
                }
                
                ctx.stroke();
            }
            
            function handleTextToolClick(e) {
                if (currentTool !== 'text') return;
                
                const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                
                const rect = canvas.getBoundingClientRect();
                textPosition = {
                    x: clientX - rect.left,
                    y: clientY - rect.top
                };
                
                textEditor.style.display = 'block';
                textEditor.style.left = Math.min(clientX + 10, window.innerWidth - textEditor.offsetWidth - 20) + 'px';
                textEditor.style.top = Math.max(clientY - textEditor.offsetHeight - 10, 20) + 'px';
                textInput.focus();
                
                e.preventDefault();
            }
            
            function confirmText() {
                const text = textInput.value.trim();
                if (text) {
                    const fontFamily = fontFamilySelect.value;
                    const fontSize = fontSizeSelect.value;
                    const color = textColorSelect.value;
                    
                    ctx.font = `${fontSize} ${fontFamily}`;
                    ctx.fillStyle = color;
                    ctx.fillText(text, textPosition.x, textPosition.y);
                    
                    pages[currentPageIndex] = canvas.toDataURL();
                }
                
                textInput.value = '';
                textEditor.style.display = 'none';
            }
            
            function cancelText() {
                textInput.value = '';
                textEditor.style.display = 'none';
            }
            
            function handleShapeToolClick(e) {
                if (currentTool !== 'shape') return;
                
                const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                
                const rect = canvas.getBoundingClientRect();
                shapeStartX = clientX - rect.left;
                shapeStartY = clientY - rect.top;
                
                shapeSelector.style.display = 'block';
                shapeSelector.style.left = Math.min(clientX + 10, window.innerWidth - shapeSelector.offsetWidth - 20) + 'px';
                shapeSelector.style.top = Math.max(clientY - shapeSelector.offsetHeight - 10, 20) + 'px';
                
                e.preventDefault();
            }
            
            function drawShape(shape, startX, startY, endX, endY, isTemp = false) {
                const ctxToUse = isTemp ? tempCtx : ctx;
                
                ctxToUse.save();
                ctxToUse.strokeStyle = currentColor;
                ctxToUse.lineWidth = penWidth;
                ctxToUse.fillStyle = 'transparent';
                
                const isSquare = shape === 'rectangle' && (e.shiftKey || shape === 'square');
                
                switch(shape) {
                    case 'line':
                        ctxToUse.beginPath();
                        ctxToUse.moveTo(startX, startY);
                        ctxToUse.lineTo(endX, endY);
                        ctxToUse.stroke();
                        break;
                        
                    case 'rectangle':
                        if (isSquare) {
                            const size = Math.max(Math.abs(endX - startX), Math.abs(endY - startY));
                            const x = endX > startX ? startX : startX - size;
                            const y = endY > startY ? startY : startY - size;
                            ctxToUse.beginPath();
                            ctxToUse.rect(x, y, size, size);
                            ctxToUse.stroke();
                        } else {
                            ctxToUse.beginPath();
                            ctxToUse.rect(startX, startY, endX - startX, endY - startY);
                            ctxToUse.stroke();
                        }
                        break;
                        
                    case 'circle':
                        const radius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                        ctxToUse.beginPath();
                        ctxToUse.arc(startX, startY, radius, 0, Math.PI * 2);
                        ctxToUse.stroke();
                        break;
                        
                    case 'parallelogram':
                        ctxToUse.beginPath();
                        const paraOffset = (endX - startX) * 0.3;
                        ctxToUse.moveTo(startX + paraOffset, startY);
                        ctxToUse.lineTo(endX, startY);
                        ctxToUse.lineTo(endX - paraOffset, endY);
                        ctxToUse.lineTo(startX, endY);
                        ctxToUse.closePath();
                        ctxToUse.stroke();
                        break;
                        
                    case 'trapezoid':
                        ctxToUse.beginPath();
                        const trapOffset = (endX - startX) * 0.2;
                        ctxToUse.moveTo(startX + trapOffset, startY);
                        ctxToUse.lineTo(endX - trapOffset, startY);
                        ctxToUse.lineTo(endX, endY);
                        ctxToUse.lineTo(startX, endY);
                        ctxToUse.closePath();
                        ctxToUse.stroke();
                        break;
                }
                
                ctxToUse.restore();
            }
            
            function handleShapeSelection(e) {
                const shape = e.currentTarget.dataset.shape;
                if (!shape) return;
                
                currentShape = shape;
                shapeSelector.style.display = 'none';
                
                canvas.classList.add('drawing-cursor');
                
                tempCtx.clearRect(0, 0, canvas.width, canvas.height);
                tempCtx.drawImage(canvas, 0, 0);
                
                let isDrawingShape = false;
                let startX = shapeStartX;
                let startY = shapeStartY;
                
                function startShape(e) {
                    isDrawingShape = true;
                    
                    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                    const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                    
                    const rect = canvas.getBoundingClientRect();
                    startX = clientX - rect.left;
                    startY = clientY - rect.top;
                    
                    tempCtx.clearRect(0, 0, canvas.width, canvas.height);
                    tempCtx.drawImage(canvas, 0, 0);
                    
                    e.preventDefault();
                }
                
                function drawTempShape(e) {
                    if (!isDrawingShape) return;
                    
                    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                    const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                    
                    const rect = canvas.getBoundingClientRect();
                    const endX = clientX - rect.left;
                    const endY = clientY - rect.top;
                    
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(tempCanvas, 0, 0);
                    
                    const shapeToDraw = (currentShape === 'rectangle' && e.shiftKey) ? 'square' : currentShape;
                    drawShape(shapeToDraw, startX, startY, endX, endY, false);
                    
                    e.preventDefault();
                }
                
                function endShape(e) {
                    if (!isDrawingShape) return;
                    isDrawingShape = false;
                    
                    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                    const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                    
                    const rect = canvas.getBoundingClientRect();
                    const endX = clientX - rect.left;
                    const endY = clientY - rect.top;
                    
                    const shapeToDraw = (currentShape === 'rectangle' && e.shiftKey) ? 'square' : currentShape;
                    drawShape(shapeToDraw, startX, startY, endX, endY, false);
                    
                    pages[currentPageIndex] = canvas.toDataURL();
                    
                    canvas.removeEventListener('mousedown', startShape);
                    canvas.removeEventListener('mousemove', drawTempShape);
                    canvas.removeEventListener('mouseup', endShape);
                    canvas.removeEventListener('mouseout', endShape);
                    canvas.removeEventListener('touchstart', startShape);
                    canvas.removeEventListener('touchmove', drawTempShape);
                    canvas.removeEventListener('touchend', endShape);
                    
                    canvas.classList.remove('drawing-cursor');
                    
                    e.preventDefault();
                }
                
                canvas.addEventListener('mousedown', startShape);
                canvas.addEventListener('mousemove', drawTempShape);
                canvas.addEventListener('mouseup', endShape);
                canvas.addEventListener('mouseout', endShape);
                canvas.addEventListener('touchstart', startShape);
                canvas.addEventListener('touchmove', drawTempShape);
                canvas.addEventListener('touchend', endShape);
            }
            
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            
            canvas.addEventListener('touchstart', startDrawing);
            canvas.addEventListener('touchmove', draw);
            canvas.addEventListener('touchend', stopDrawing);
            
            canvas.addEventListener('click', function(e) {
                if (currentTool === 'stroke-eraser') {
                    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                    const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                    
                    const rect = canvas.getBoundingClientRect();
                    const x = clientX - rect.left;
                    const y = clientY - rect.top;
                    
                    eraseStrokeAtPoint(x, y);
                }
            });
            
            canvas.addEventListener('click', handleTextToolClick);
            
            canvas.addEventListener('click', handleShapeToolClick);
            
            colorButtons.forEach(button => {
                button.addEventListener('click', function() {
                    colorButtons.forEach(btn => btn.classList.remove('selected'));
                    this.classList.add('selected');
                    currentColor = this.dataset.color;
                    currentTool = 'pen';
                });
            });
            
            eraserBtn.addEventListener('click', function() {
                currentTool = 'eraser';
                colorButtons.forEach(btn => btn.classList.remove('selected'));
            });
            
            strokeEraserBtn.addEventListener('click', function() {
                currentTool = 'stroke-eraser';
                colorButtons.forEach(btn => btn.classList.remove('selected'));
            });
            
            textToolBtn.addEventListener('click', function() {
                currentTool = 'text';
                colorButtons.forEach(btn => btn.classList.remove('selected'));
            });
            
            shapeToolBtn.addEventListener('click', function() {
                currentTool = 'shape';
                colorButtons.forEach(btn => btn.classList.remove('selected'));
            });
            
            clearBtn.addEventListener('click', function() {
                if (confirm('确定要清空当前画板吗？')) {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    pages[currentPageIndex] = canvas.toDataURL();
                    strokes = [];
                }
            });
            
            confirmTextBtn.addEventListener('click', confirmText);
            cancelTextBtn.addEventListener('click', cancelText);
            closeTextEditor.addEventListener('click', cancelText);
            
            shapeOptions.forEach(option => {
                option.addEventListener('click', handleShapeSelection);
            });
            closeShapeSelector.addEventListener('click', function() {
                shapeSelector.style.display = 'none';
            });
            
            function loadPage(index) {
                const img = new Image();
                img.onload = function() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    
                    strokes = [];
                };
                img.src = pages[index] || '';
                currentPageSpan.textContent = index + 1;
            }
            
            prevPageBtn.addEventListener('click', function() {
                if (currentPageIndex > 0) {
                    currentPageIndex--;
                    loadPage(currentPageIndex);
                }
            });
            
            nextPageBtn.addEventListener('click', function() {
                if (currentPageIndex < pages.length - 1) {
                    currentPageIndex++;
                    loadPage(currentPageIndex);
                }
            });
            
            addPageBtn.addEventListener('click', function() {
                currentPageIndex = pages.length;
                pages.push('');
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                pages[currentPageIndex] = canvas.toDataURL();
                strokes = [];
                currentPageSpan.textContent = currentPageIndex + 1;
            });
            
            changeLessonBtn.addEventListener('click', function() {
                const lessonNum = lessonInput.value;
                if (lessonNum && lessonNum > 0) {
                    lessonTitle.textContent = `第${lessonNum}课`;
                    lessonSelector.classList.add('hidden');
                } else {
                    alert('请输入有效的课程编号');
                }
            });
        });
    </script>
</body>
</html>
